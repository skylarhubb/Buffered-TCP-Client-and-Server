# TODO: Include any necessary import statements
from email.header import Header
from socket import *
from struct import pack, unpack
HEADER_LENGTH = 4

class BufferedTCPEchoServer(object):
    def __init__(self, host = '', port = 36001, buffer_size = 1024):
        # Save the buffer size to a variable. You'll need this later
        self.buffer_size = buffer_size
        
        self.tcp_server_socket = socket(AF_INET, SOCK_STREAM)
        self.tcp_server_socket.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        self.tcp_server_socket.bind((host, port))


        # This variable is used to tell the server when it should shut down. Our implementation of this server is centered
        # around one or more while loops that keeps the server listening for new connection requests and new messages from
        # a connected client. This should continue forever, or until this self.keep_running is set to False. My testing
        # code will use self.keep_running to shutdown the server for one test case 
        self.keep_running = True

        # TODO: Create and bind the server socket


    # This function starts the server listening for new connections and new messages. It initiates the core loop of our 
    # server, where we loop continuously listening for a new connection, or if we are already connected, listening for a new 
    # message. I recommend breaking the functionality up into helper functions
    # Remember that this server can only talk to one connected client at a time. We'll implement a server that
    # can connect to multiple clients at once in a future project.
    # TODO: * Listen for new connections
    #       * Accept new connections
    #       * Receive messages from the connected client until it disconnects. 
    #           * Be sure to set the bufsize parameter to self.buffer_size when calling the socket's receive function
    #       * When a message is received, remove the first ten characters and then send it back to the client. 
    #           * You can use the slice operator to remove the first 10 characters: shorter_string = my_string_variable[10:] 
    #           * You will need to package the message using the format discussed in the assignment instructions
    #       * On disconnect, attempt to accept a new connection
    #       * This process should continue until self.keep_running is set to False. (The program doesn't need immediately close when the value changes)
    #       * Shutdown the server's socket before exiting the program
    def start(self):
        self.tcp_server_socket.listen(1)
        print('SERVER: listening...')

        print("Waiting for a new connection...")
        client, address = self.tcp_server_socket.accept()
        print("Accepted connection from ", address)

        while(self.keep_running):

            message = self.receive_message(client)

            if message: 
                print('Echoing "', message, '" to ', address)
                shorter_string = message[10:]
                self.send_message(client, shorter_string)

            else:
                print("Client disconnected.")
                client.close()
                print("Waiting for a new connection...")
                client, address = self.tcp_server_socket.accept()
                print("Accepted connection from ", address)
                
            
        self.shutdown()


    def send_message(self, client, message):
        data = pack("!I" + str(len(message)) + "s", len(message), message.encode())

        client.send(data)


    def receive_message(self, client):
        try:
            first_part = client.recv(self.buffer_size)

        except ConnectionResetError:
            return False

        if(first_part):
            message_length = unpack("!I", first_part[:4])[0]
            print("Message size: " + str(message_length))
            print("Received '", first_part[4:].decode() + "'")
            message = first_part[4:].decode()

            while(len(message)) < message_length:
                try:
                    second_part = client.recv(self.buffer_size)
                
                except ConnectionResetError:
                    return False

                if(second_part):
                    print("Received '", second_part.decode() + "'")
                    message += second_part.decode()

                else:
                    print("Client disconnected.")
                    return False 
            
            return message 

        else:
            return False



    # This method is called by the autograder when it is ready to shut down your program. You should clean up your server socket
    # here. Note that all other sockets opened by the server also need to be closed once you are done with them. You should be closing
    # the individual client sockets generated by socket.accept() inside of your start() function 
    # TODO: Clean up your server socket
    def shutdown(self):
        print("SERVER: shutting down...")
        self.tcp_server_socket.close()


if __name__ == "__main__":
    BufferedTCPEchoServer(host='', port=36001, buffer_size=1024).start()